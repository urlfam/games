import fs from 'fs/promises';
import path from 'path';
import { createClient } from '@supabase/supabase-js';

const GAMES_DB_PATH = path.join(process.cwd(), 'data', 'games.json');

// Ensure data directory exists
try {
  const dir = path.dirname(GAMES_DB_PATH);
  // Using sync check to avoid async issues at top level, but create if needed in runtime
} catch (e) {
  // Ignore
}

// Cache configuration
let cachedGames: Game[] | null = null;
let lastCacheTime = 0;
const CACHE_TTL = 60 * 1000; // 60 seconds

// Cache for trending games to minimize DB calls
let cachedTrendingGames: { data: Game[]; timestamp: number } | null = null;
const TRENDING_CACHE_TTL = 60 * 1000; // 60 seconds

/**
 * Generates a slug from a string.
 * @param {string} text - The text to slugify.
 * @returns {string} The collected slug.
 */
function slugify(text: string): string {
  return text
    .toString()
    .toLowerCase()
    .normalize('NFD') // Decompose accented characters
    .replace(/[\u0300-\u036f]/g, '') // Remove accent marks
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/&/g, '-and-') // Replace & with 'and'
    .replace(/[^\w-]+/g, '') // Remove all non-word chars
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export interface Game {
  id: number;
  importedAt: string;
  title: string;
  description: string;
  iframe_url: string;
  image_url: string;
  video_url?: string;
  category: string;
  page_url: string;
  slug?: string; // We will add this field later
  seo_title?: string; // Override via Admin
  seo_description?: string; // Override via Admin

  // SEO Image Metadata (generated by Gemini AI in n8n workflow)
  image_alt?: string; // SEO-optimized alt text (max 125 chars)
  image_title?: string; // Title attribute for tooltip (max 60 chars)
  image_description?: string; // Detailed description for Schema.org (80-120 words)
  image_keywords?: string[]; // Array of SEO keywords

  // FAQ Schema (generated by Gemini AI in n8n workflow)
  faq_schema?: Array<{
    question: string;
    answer: string;
  }>;

  // Tags (scraped from the game page)
  tags?: string[];

  // YouTube Video URL (scraped from the game page)
  youtube_video_url?: string;

  // Gameplay Screenshot (captured by validator)
  gameplay_screenshot_url?: string;
  gameplay_filename?: string;

  // Mobile optimized images (optional - added later)
  mobile_image_url?: string; // 2x3 aspect ratio (vertical)
  mobile_1x1_url?: string; // 1x1 aspect ratio (square)
}

export type MinimalGame = Pick<
  Game,
  | 'id'
  | 'title'
  | 'slug'
  | 'image_url'
  | 'video_url'
  | 'category'
  | 'image_alt'
  | 'mobile_image_url'
  | 'mobile_1x1_url'
>;

export function minimizeGame(game: Game): MinimalGame {
  return {
    id: game.id,
    title: game.title,
    slug: game.slug!, // valid games always have a slug after getAllGames
    image_url: game.image_url,
    video_url: game.video_url,
    category: game.category,
    image_alt: game.image_alt, // Optional
    mobile_image_url: game.mobile_image_url,
    mobile_1x1_url: game.mobile_1x1_url,
  };
}

/**
 * Reads the games.json file and returns all games.
 * @returns {Promise<Game[]>} A promise that resolves to an array of games.
 */
export async function getAllGames(): Promise<Game[]> {
  // Check memory cache
  if (cachedGames && Date.now() - lastCacheTime < CACHE_TTL) {
    return cachedGames;
  }

  try {
    const data = await fs.readFile(GAMES_DB_PATH, 'utf-8');
    cachedGames = JSON.parse(data);

    // FIX: Polyfill missing slugs to prevent URL errors
    let needsSave = false;
    
    cachedGames = cachedGames!.map((game) => {
      if (!game.slug) {
        // Generate missing slug from title
        game.slug = slugify(game.title || `game-${game.id}`);
        needsSave = true; // Mark that we found issues in the file
        console.warn(`[AutoFix] Generated missing slug for game ID ${game.id}: ${game.slug}`);
      }
      return game;
    });

    // If we found missing slugs, treat this as a migration and attempt to save back to disk asynchronously
    // We don't await this to keep the read fast, and we catch errors silently.
    if (needsSave) {
        // We use a non-blocking write to fix the file permanently.
        // We re-serialize the *fixed* games array.
        fs.writeFile(GAMES_DB_PATH, JSON.stringify(cachedGames, null, 2), 'utf-8')
           .then(() => console.log('[AutoFix] Successfully saved generated slugs to games.json'))
           .catch((e) => console.error('[AutoFix] Failed to save generated slugs:', e));
    }

    lastCacheTime = Date.now();
    return cachedGames!;
  } catch (error) {
    console.error('Error reading games database:', error);
    return [];
  }
}

/**
 * Finds a single game by its slug.
 * @param {string} slug - The slug of the game to find.
 * @returns {Promise<Game | undefined>} A promise that resolves to the game object or undefined if not found.
 */
export async function getGameBySlug(slug: string): Promise<Game | undefined> {
  const games = await getAllGames();
  return games.find((game) => game.slug === slug);
}

/**
 * Gets all unique categories from games with their count.
 * @returns {Promise<Array<{name: string, count: number, slug: string}>>} Array of categories with game count.
 */
export async function getCategories(): Promise<
  Array<{ name: string; count: number; slug: string }>
> {
  const games = await getAllGames();
  const categoryMap = new Map<string, number>();

  games.forEach((game) => {
    const category = game.category;
    categoryMap.set(category, (categoryMap.get(category) || 0) + 1);
  });

  return Array.from(categoryMap.entries())
    .map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }))
    .sort((a, b) => b.count - a.count); // Sort by game count descending
}

/**
 * Gets new games (recently imported).
 * @param {number} limit - Maximum number of games to return.
 * @returns {Promise<Game[]>} Array of newest games.
 */
export async function getNewGames(limit: number = 20): Promise<Game[]> {
  const games = await getAllGames();
  return games
    .sort(
      (a, b) =>
        new Date(b.importedAt).getTime() - new Date(a.importedAt).getTime(),
    )
    .slice(0, limit);
}

/**
 * Sorts a list of games by play count (descending).
 * @param {Game[]} games - The list of games to sort.
 * @returns {Promise<Game[]>} The sorted list of games.
 */
export async function sortGamesByPlays(games: Game[]): Promise<Game[]> {
  if (games.length === 0) return [];

  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    );

    // Get slugs of the games we want to sort
    const slugs = games.map((g) => g.slug).filter(Boolean) as string[];

    if (slugs.length === 0) return games;

    const { data: stats } = await supabase
      .from('game_stats')
      .select('game_slug, plays')
      .in('game_slug', slugs);

    if (stats && stats.length > 0) {
      const playsMap = new Map(stats.map((s) => [s.game_slug, s.plays]));

      return [...games].sort((a, b) => {
        const playsA = playsMap.get(a.slug!) || 0;
        const playsB = playsMap.get(b.slug!) || 0;
        return playsB - playsA;
      });
    }
  } catch (error) {
    console.error('Error sorting games by plays:', error);
  }

  return games;
}

/**
 * Gets trending/popular games.
 * Fetches play counts from Supabase and sorts by popularity.
 * Optimized to fetch top stats first instead of sending all IDs.
 * @param {number} limit - Maximum number of games to return.
 * @returns {Promise<Game[]>} Array of trending games.
 */
export async function getTrendingGames(limit: number = 20): Promise<Game[]> {
  // Check memory cache
  if (
    cachedTrendingGames &&
    Date.now() - cachedTrendingGames.timestamp < TRENDING_CACHE_TTL &&
    cachedTrendingGames.data.length >= limit
  ) {
    return cachedTrendingGames.data.slice(0, limit);
  }

  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    );

    // Efficiently fetch only the top played games from DB
    // Fetch a bit more than limit to account for potential sync issues
    const fetchLimit = limit < 50 ? 50 : limit;

    const { data: stats } = await supabase
      .from('game_stats')
      .select('game_slug, plays')
      .order('plays', { ascending: false })
      .limit(fetchLimit);

    const allGames = await getAllGames();
    let resultGames: Game[] = [];

    if (stats && stats.length > 0) {
      const playsMap = new Map(stats.map((s) => [s.game_slug, s.plays]));
      const trendingSlugs = new Set(stats.map((s) => s.game_slug));

      // Filter games that are in the top stats
      const trendingGames = allGames.filter(
        (g) => g.slug && trendingSlugs.has(g.slug),
      );

      // Sort them by plays
      trendingGames.sort((a, b) => {
        const playsA = playsMap.get(a.slug!) || 0;
        const playsB = playsMap.get(b.slug!) || 0;
        return playsB - playsA;
      });

      resultGames = trendingGames;
    }

    // Fill with random/new if not enough
    if (resultGames.length < limit) {
      const usedSlugs = new Set(resultGames.map((g) => g.slug));
      const remainingGames = allGames.filter((g) => !usedSlugs.has(g.slug));
      // Shuffle remaining
      const shuffled = [...remainingGames].sort(() => Math.random() - 0.5);
      resultGames = [
        ...resultGames,
        ...shuffled.slice(0, limit - resultGames.length),
      ];
    }

    // Update cache
    cachedTrendingGames = {
      data: resultGames,
      timestamp: Date.now(),
    };

    return resultGames.slice(0, limit);
  } catch (error) {
    console.error('Error fetching trending games:', error);
    // Return cached if available
    if (cachedTrendingGames) return cachedTrendingGames.data.slice(0, limit);

    // Fallback if everything fails
    const games = await getAllGames();
    return games.slice(0, limit);
  }
}

/**
 * Gets all unique tags from games with their count.
 * @returns {Promise<Array<{name: string, count: number, slug: string}>>} Array of tags with game count.
 */
export async function getAllTags(): Promise<
  Array<{ name: string; count: number; slug: string }>
> {
  const games = await getAllGames();
  const tagMap = new Map<string, number>();

  games.forEach((game) => {
    if (game.tags && Array.isArray(game.tags)) {
      game.tags.forEach((tag) => {
        tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
      });
    }
  });

  return Array.from(tagMap.entries())
    .map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }))
    .sort((a, b) => b.count - a.count); // Sort by game count descending
}

/**
 * Finds games by a specific tag.
 * @param {string} tagSlug - The slug of the tag to filter by.
 * @returns {Promise<Game[]>} A promise that resolves to an array of games with the specified tag.
 */
export async function getGamesByTag(tagSlug: string): Promise<Game[]> {
  const games = await getAllGames();
  return games.filter((game) => {
    if (!game.tags || !Array.isArray(game.tags)) return false;
    return game.tags.some(
      (tag) => tag.toLowerCase().replace(/\s+/g, '-') === tagSlug,
    );
  });
}

/**
 * Saves a game object to the games.json file.
 * @param {Game} updatedGame - The game object to save.
 * @returns {Promise<void>} A promise that resolves when the game is saved.
 */
export async function saveGame(updatedGame: Game): Promise<void> {
  try {
    // 1. Read current file
    const data = await fs.readFile(GAMES_DB_PATH, 'utf-8');
    let games: Game[] = JSON.parse(data);

    // 2. Find index
    // Use slug if available, else id. Best to rely on id if stable, but slug is the key used in URLs.
    // Let's rely on ID first, then Slug.
    const index = games.findIndex((g) => g.id === updatedGame.id);

    if (index !== -1) {
      // Update
      games[index] = { ...games[index], ...updatedGame };
    } else {
      // Create - Generate new ID if needed
      if (!updatedGame.id) {
        const maxId = games.reduce((max, g) => (g.id > max ? g.id : max), 0);
        updatedGame.id = maxId + 1;
      }
      games.push(updatedGame);
    }

    // 3. Write back
    await fs.writeFile(GAMES_DB_PATH, JSON.stringify(games, null, 2), 'utf-8');

    // 4. Invalidate Cache
    cachedGames = null;
    lastCacheTime = 0;
  } catch (error) {
    console.error('Error saving game:', error);
    throw new Error('Failed to save game to database');
  }
}

/**
 * Deletes a game by its slug.
 * @param {string} slug - The slug of the game to delete.
 */
export async function deleteGame(slug: string): Promise<void> {
  try {
    const data = await fs.readFile(GAMES_DB_PATH, 'utf-8');
    let games: Game[] = JSON.parse(data);

    const initialLength = games.length;
    games = games.filter((g) => g.slug !== slug);

    if (games.length !== initialLength) {
      await fs.writeFile(GAMES_DB_PATH, JSON.stringify(games, null, 2), 'utf-8');
      cachedGames = null;
      lastCacheTime = 0;
    }
  } catch (error) {
    console.error('Error deleting game:', error);
    throw new Error('Failed to delete game');
  }
}

/**
 * Deletes all games from the database.
 * WARNING: This action is irreversible.
 */
export async function deleteAllGames(): Promise<void> {
  try {
    // Write empty array to file
    await fs.writeFile(GAMES_DB_PATH, JSON.stringify([], null, 2), 'utf-8');

    // Invalidate Cache
    cachedGames = null;
    lastCacheTime = 0;
  } catch (error) {
    console.error('Error deleting all games:', error);
    throw new Error('Failed to delete all games');
  }
}

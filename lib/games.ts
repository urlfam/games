import fs from 'fs/promises';
import path from 'path';
import { createClient } from '@supabase/supabase-js';

// The data directory is now inside the container, at a writable location.
const DATA_DIR = path.join(process.cwd(), 'data');
const GAMES_DB_PATH = path.join(DATA_DIR, 'games.json');

export interface Game {
  id: number;
  importedAt: string;
  title: string;
  description: string;
  iframe_url: string;
  image_url: string;
  video_url?: string;
  category: string;
  page_url: string;
  slug?: string; // We will add this field later

  // SEO Image Metadata (generated by Gemini AI in n8n workflow)
  image_alt?: string; // SEO-optimized alt text (max 125 chars)
  image_title?: string; // Title attribute for tooltip (max 60 chars)
  image_description?: string; // Detailed description for Schema.org (80-120 words)
  image_keywords?: string[]; // Array of SEO keywords

  // FAQ Schema (generated by Gemini AI in n8n workflow)
  faq_schema?: Array<{
    question: string;
    answer: string;
  }>;

  // Tags (scraped from the game page)
  tags?: string[];

  // YouTube Video URL (scraped from the game page)
  youtube_video_url?: string;
}

/**
 * Reads the games.json file and returns all games.
 * @returns {Promise<Game[]>} A promise that resolves to an array of games.
 */
export async function getAllGames(): Promise<Game[]> {
  try {
    const data = await fs.readFile(GAMES_DB_PATH, 'utf-8');
    const games: Game[] = JSON.parse(data);

    // Add a 'slug' to each game based on its page_url for easier linking
    return games.map((game) => ({
      ...game,
      slug: game.slug || game.page_url.substring(game.page_url.lastIndexOf('/') + 1),
    }));
  } catch (error) {
    // If the file doesn't exist or is empty, return an empty array
    console.error('Could not read games.json:', error);
    return [];
  }
}

/**
 * Finds a single game by its slug.
 * @param {string} slug - The slug of the game to find.
 * @returns {Promise<Game | undefined>} A promise that resolves to the game object or undefined if not found.
 */
export async function getGameBySlug(slug: string): Promise<Game | undefined> {
  const games = await getAllGames();
  return games.find((game) => game.slug === slug);
}

/**
 * Gets all unique categories from games with their count.
 * @returns {Promise<Array<{name: string, count: number, slug: string}>>} Array of categories with game count.
 */
export async function getCategories(): Promise<
  Array<{ name: string; count: number; slug: string }>
> {
  const games = await getAllGames();
  const categoryMap = new Map<string, number>();

  games.forEach((game) => {
    const category = game.category;
    categoryMap.set(category, (categoryMap.get(category) || 0) + 1);
  });

  return Array.from(categoryMap.entries())
    .map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }))
    .sort((a, b) => b.count - a.count); // Sort by game count descending
}

/**
 * Gets new games (recently imported).
 * @param {number} limit - Maximum number of games to return.
 * @returns {Promise<Game[]>} Array of newest games.
 */
export async function getNewGames(limit: number = 20): Promise<Game[]> {
  const games = await getAllGames();
  return games
    .sort(
      (a, b) =>
        new Date(b.importedAt).getTime() - new Date(a.importedAt).getTime(),
    )
    .slice(0, limit);
}

/**
 * Sorts a list of games by play count (descending).
 * @param {Game[]} games - The list of games to sort.
 * @returns {Promise<Game[]>} The sorted list of games.
 */
export async function sortGamesByPlays(games: Game[]): Promise<Game[]> {
  if (games.length === 0) return [];

  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    );

    // Get slugs of the games we want to sort
    const slugs = games.map((g) => g.slug).filter(Boolean) as string[];

    if (slugs.length === 0) return games;

    const { data: stats } = await supabase
      .from('game_stats')
      .select('game_slug, plays')
      .in('game_slug', slugs);

    if (stats && stats.length > 0) {
      const playsMap = new Map(stats.map((s) => [s.game_slug, s.plays]));

      return [...games].sort((a, b) => {
        const playsA = playsMap.get(a.slug!) || 0;
        const playsB = playsMap.get(b.slug!) || 0;
        return playsB - playsA;
      });
    }
  } catch (error) {
    console.error('Error sorting games by plays:', error);
  }

  return games;
}

/**
 * Gets trending/popular games.
 * Fetches play counts from Supabase and sorts by popularity.
 * @param {number} limit - Maximum number of games to return.
 * @returns {Promise<Game[]>} Array of trending games.
 */
export async function getTrendingGames(limit: number = 20): Promise<Game[]> {
  const games = await getAllGames();
  const sorted = await sortGamesByPlays(games);

  // If we have results, return them
  if (sorted.length > 0) {
    return sorted.slice(0, limit);
  }

  // Fallback: Shuffle array and take limit
  const shuffled = [...games].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, limit);
}

/**
 * Gets all unique tags from games with their count.
 * @returns {Promise<Array<{name: string, count: number, slug: string}>>} Array of tags with game count.
 */
export async function getAllTags(): Promise<
  Array<{ name: string; count: number; slug: string }>
> {
  const games = await getAllGames();
  const tagMap = new Map<string, number>();

  games.forEach((game) => {
    if (game.tags && Array.isArray(game.tags)) {
      game.tags.forEach((tag) => {
        tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
      });
    }
  });

  return Array.from(tagMap.entries())
    .map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }))
    .sort((a, b) => b.count - a.count); // Sort by game count descending
}

/**
 * Finds games by a specific tag.
 * @param {string} tagSlug - The slug of the tag to filter by.
 * @returns {Promise<Game[]>} A promise that resolves to an array of games with the specified tag.
 */
export async function getGamesByTag(tagSlug: string): Promise<Game[]> {
  const games = await getAllGames();
  return games.filter((game) => {
    if (!game.tags || !Array.isArray(game.tags)) return false;
    return game.tags.some(
      (tag) => tag.toLowerCase().replace(/\s+/g, '-') === tagSlug,
    );
  });
}

import fs from 'fs/promises';
import path from 'path';
import { createClient } from '@supabase/supabase-js';

// The data directory is now inside the container, at a writable location.
const DATA_DIR = path.join(process.cwd(), 'data');
const GAMES_DB_PATH = path.join(DATA_DIR, 'games.json');

// Cache configuration
let cachedGames: Game[] | null = null;
let lastCacheTime = 0;
const CACHE_TTL = 60 * 1000; // 60 seconds

// Cache for trending games to minimize DB calls
let cachedTrendingGames: { data: Game[]; timestamp: number } | null = null;
const TRENDING_CACHE_TTL = 60 * 1000; // 60 seconds

export interface Game {
  id: number;
  importedAt: string;
  title: string;
  description: string;
  iframe_url: string;
  image_url: string;
  video_url?: string;
  category: string;
  page_url: string;
  slug?: string; // We will add this field later
  seo_title?: string; // Override via Admin
  seo_description?: string; // Override via Admin

  // SEO Image Metadata (generated by Gemini AI in n8n workflow)
  image_alt?: string; // SEO-optimized alt text (max 125 chars)
  image_title?: string; // Title attribute for tooltip (max 60 chars)
  image_description?: string; // Detailed description for Schema.org (80-120 words)
  image_keywords?: string[]; // Array of SEO keywords

  // FAQ Schema (generated by Gemini AI in n8n workflow)
  faq_schema?: Array<{
    question: string;
    answer: string;
  }>;

  // Tags (scraped from the game page)
  tags?: string[];

  // YouTube Video URL (scraped from the game page)
  youtube_video_url?: string;

  // Gameplay Screenshot (captured by validator)
  gameplay_screenshot_url?: string;
  gameplay_filename?: string;

  // Mobile optimized images (optional - added later)
  mobile_image_url?: string; // 2x3 aspect ratio (vertical)
  mobile_1x1_url?: string; // 1x1 aspect ratio (square)
}

export type MinimalGame = Pick<
  Game,
  | 'id'
  | 'title'
  | 'slug'
  | 'image_url'
  | 'video_url'
  | 'category'
  | 'image_alt'
  | 'mobile_image_url'
  | 'mobile_1x1_url'
>;

export function minimizeGame(game: Game): MinimalGame {
  return {
    id: game.id,
    title: game.title,
    slug: game.slug!, // valid games always have a slug after getAllGames
    image_url: game.image_url,
    video_url: game.video_url,
    category: game.category,
    image_alt: game.image_alt, // Optional
    mobile_image_url: game.mobile_image_url,
    mobile_1x1_url: game.mobile_1x1_url,
  };
}

/**
 * Reads the games.json file and returns all games.
 * @returns {Promise<Game[]>} A promise that resolves to an array of games.
 */
export async function getAllGames(): Promise<Game[]> {
  // Check in-memory cache first
  if (cachedGames && Date.now() - lastCacheTime < CACHE_TTL) {
    return cachedGames;
  }

  try {
    const data = await fs.readFile(GAMES_DB_PATH, 'utf-8');
    const games: Game[] = JSON.parse(data);

    // Add a 'slug' to each game based on its page_url for easier linking
    let processedGames = games.map((game) => ({
      ...game,
      slug: game.slug || game.page_url.substring(game.page_url.lastIndexOf('/') + 1),
    }));

    // Fetch overrides from Supabase
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      );
      const { data: overrides, error } = await supabase
        .from('game_overrides')
        .select('*');

      if (!error && overrides && overrides.length > 0) {
        const overridesMap = new Map(overrides.map((o) => [o.slug, o]));
        processedGames = processedGames.map((game) => {
          const override = overridesMap.get(game.slug!);
          if (override) {
            // Merge override data. Prioritize override fields.
            return { ...game, ...override };
          }
          return game;
        });
      }
    } catch (e) {
      // Ignore errors (e.g. table doesn't exist yet) to not break the site
      console.warn('Error fetching game overrides:', e);
    }

    // Update cache
    cachedGames = processedGames;
    lastCacheTime = Date.now();

    return processedGames;
  } catch (error) {
    // If the file doesn't exist or is empty, return an empty array
    console.error('Could not read games.json:', error);
    return [];
  }
}

/**
 * Finds a single game by its slug.
 * @param {string} slug - The slug of the game to find.
 * @returns {Promise<Game | undefined>} A promise that resolves to the game object or undefined if not found.
 */
export async function getGameBySlug(slug: string): Promise<Game | undefined> {
  const games = await getAllGames();
  return games.find((game) => game.slug === slug);
}

/**
 * Gets all unique categories from games with their count.
 * @returns {Promise<Array<{name: string, count: number, slug: string}>>} Array of categories with game count.
 */
export async function getCategories(): Promise<
  Array<{ name: string; count: number; slug: string }>
> {
  const games = await getAllGames();
  const categoryMap = new Map<string, number>();

  games.forEach((game) => {
    const category = game.category;
    categoryMap.set(category, (categoryMap.get(category) || 0) + 1);
  });

  return Array.from(categoryMap.entries())
    .map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }))
    .sort((a, b) => b.count - a.count); // Sort by game count descending
}

/**
 * Gets new games (recently imported).
 * @param {number} limit - Maximum number of games to return.
 * @returns {Promise<Game[]>} Array of newest games.
 */
export async function getNewGames(limit: number = 20): Promise<Game[]> {
  const games = await getAllGames();
  return games
    .sort(
      (a, b) =>
        new Date(b.importedAt).getTime() - new Date(a.importedAt).getTime(),
    )
    .slice(0, limit);
}

/**
 * Sorts a list of games by play count (descending).
 * @param {Game[]} games - The list of games to sort.
 * @returns {Promise<Game[]>} The sorted list of games.
 */
export async function sortGamesByPlays(games: Game[]): Promise<Game[]> {
  if (games.length === 0) return [];

  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    );

    // Get slugs of the games we want to sort
    const slugs = games.map((g) => g.slug).filter(Boolean) as string[];

    if (slugs.length === 0) return games;

    const { data: stats } = await supabase
      .from('game_stats')
      .select('game_slug, plays')
      .in('game_slug', slugs);

    if (stats && stats.length > 0) {
      const playsMap = new Map(stats.map((s) => [s.game_slug, s.plays]));

      return [...games].sort((a, b) => {
        const playsA = playsMap.get(a.slug!) || 0;
        const playsB = playsMap.get(b.slug!) || 0;
        return playsB - playsA;
      });
    }
  } catch (error) {
    console.error('Error sorting games by plays:', error);
  }

  return games;
}

/**
 * Gets trending/popular games.
 * Fetches play counts from Supabase and sorts by popularity.
 * Optimized to fetch top stats first instead of sending all IDs.
 * @param {number} limit - Maximum number of games to return.
 * @returns {Promise<Game[]>} Array of trending games.
 */
export async function getTrendingGames(limit: number = 20): Promise<Game[]> {
  // Check memory cache
  if (
    cachedTrendingGames &&
    Date.now() - cachedTrendingGames.timestamp < TRENDING_CACHE_TTL &&
    cachedTrendingGames.data.length >= limit
  ) {
    return cachedTrendingGames.data.slice(0, limit);
  }

  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    );

    // Efficiently fetch only the top played games from DB
    // Fetch a bit more than limit to account for potential sync issues
    const fetchLimit = limit < 50 ? 50 : limit;
    
    const { data: stats } = await supabase
      .from('game_stats')
      .select('game_slug, plays')
      .order('plays', { ascending: false })
      .limit(fetchLimit);

    const allGames = await getAllGames();
    let resultGames: Game[] = [];

    if (stats && stats.length > 0) {
      const playsMap = new Map(stats.map((s) => [s.game_slug, s.plays]));
      const trendingSlugs = new Set(stats.map((s) => s.game_slug));

      // Filter games that are in the top stats
      const trendingGames = allGames.filter((g) => g.slug && trendingSlugs.has(g.slug));

      // Sort them by plays
      trendingGames.sort((a, b) => {
        const playsA = playsMap.get(a.slug!) || 0;
        const playsB = playsMap.get(b.slug!) || 0;
        return playsB - playsA;
      });

      resultGames = trendingGames;
    }

    // Fill with random/new if not enough
    if (resultGames.length < limit) {
      const usedSlugs = new Set(resultGames.map(g => g.slug));
      const remainingGames = allGames.filter(g => !usedSlugs.has(g.slug));
      // Shuffle remaining
      const shuffled = [...remainingGames].sort(() => Math.random() - 0.5);
      resultGames = [...resultGames, ...shuffled.slice(0, limit - resultGames.length)];
    }
    
    // Update cache
    cachedTrendingGames = {
      data: resultGames,
      timestamp: Date.now(),
    };

    return resultGames.slice(0, limit);

  } catch (error) {
    console.error("Error fetching trending games:", error);
    // Return cached if available
    if (cachedTrendingGames) return cachedTrendingGames.data.slice(0, limit);
    
    // Fallback if everything fails
    const games = await getAllGames();
    return games.slice(0, limit);
  }
}

/**
 * Gets all unique tags from games with their count.
 * @returns {Promise<Array<{name: string, count: number, slug: string}>>} Array of tags with game count.
 */
export async function getAllTags(): Promise<
  Array<{ name: string; count: number; slug: string }>
> {
  const games = await getAllGames();
  const tagMap = new Map<string, number>();

  games.forEach((game) => {
    if (game.tags && Array.isArray(game.tags)) {
      game.tags.forEach((tag) => {
        tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
      });
    }
  });

  return Array.from(tagMap.entries())
    .map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }))
    .sort((a, b) => b.count - a.count); // Sort by game count descending
}

/**
 * Finds games by a specific tag.
 * @param {string} tagSlug - The slug of the tag to filter by.
 * @returns {Promise<Game[]>} A promise that resolves to an array of games with the specified tag.
 */
export async function getGamesByTag(tagSlug: string): Promise<Game[]> {
  const games = await getAllGames();
  return games.filter((game) => {
    if (!game.tags || !Array.isArray(game.tags)) return false;
    return game.tags.some(
      (tag) => tag.toLowerCase().replace(/\s+/g, '-') === tagSlug,
    );
  });
}
